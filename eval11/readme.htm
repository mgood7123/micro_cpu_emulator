<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>evaluateExpression: A Function to Evaluate Arithmetic Expressions</TITLE>

<META NAME="description" CONTENT="Documentation for AnaGram's
       evaluateExpression example">

</HEAD>


<BODY BGCOLOR="#ffffff"
 TEXT="#000000" LINK="#0033CC"
 VLINK="#CC0033" ALINK="#CC0099">

<P>
<IMG ALIGN="right" SRC="pslrb6e.gif" ALT="Parsifal Software"
         WIDTH=181 HEIGHT=25>
<BR CLEAR="RIGHT">
</P>


<HR>
<P>
<H2>evaluateExpression:<BR> A Function to Evaluate Arithmetic Expressions</H2>

<HR>



<P><B>evaluateExpression </B>is a convenient utility for parsing and evaluating
arithmetic expressions at runtime. You can use it, for example, to evaluate
expressions read from data files or configuration files or expressions
entered directly by users. evaluateExpression is provided as an example of the
use of the <B><A HREF="http://www.parsifalsoft.com/">AnaGram</A></B> parser generator.
</P>

<P>This example has been specially constructed so that you can easily adapt it to your specific
requirements, <B>even if you do not have a copy of
AnaGram.</B></P>

<P>evaluateExpression may be freely copied and modified.</P>

<P><B>To use the evaluateExpression function in your program </B>simply
add EVALKERN.C and EVALWRAP.C (with headers EVALKERN.H and EVALDEFS.H) to your project
and call the function as described below.</P>
<P>The evaluateExpression example consists of seven files:
</P>
<UL>
<LI>A syntax file, EVALKERN.SYN, which defines the parser itself.</LI>
</UL>
<UL>
<LI>The c file</A> EVALKERN.C, which has been generated by AnaGram from the syntax file</LI>
<LI>The h file EVALKERN.H, similarly generated by AnaGram</LI>
</UL>
<UL><LI>A wrapper module, EVALWRAP.C, which implements support
functions and the evaluateExpression interface function.</LI>
<LI>A header file, EVALDEFS.H, which provides global
declarations.</LI>
<LI>A demo program, EVALDEMO.C, which illustrates the use of
evaluateExpression.</LI>
<LI>A test file, TEST, which contains a self-commented, sample expression
string with a variety of expressions.</LI>
</UL>

<IMG SRC="diagr895.gif" WIDTH=555 HEIGHT=266
BORDER=0 ALT="explanatory diagram"></LEFT>

<H3>int evaluateExpression(char *expressionString);</H3>
<P>
evaluateExpression is defined in the wrapper module EVALWRAP.C. The example has been
set up with a wrapper module to allow you more flexibility in case you do not have a
copy of AnaGram. You can modify the wrapper module to suit your needs.
evaluateExpression calls the parser function, which is named evalKernel(). The parser
file, which has been produced by AnaGram from the specs in EVALKERN.SYN, is EVALKERN.C.
</P>

<P> EVALWRAP.C also has definitions of the functions called by the parser, which are
pushChar, locateVariable, pushArg, callFunction, and checkZero. You can modify these
functions as necessary.
</P>
<P>Finally, EVALDEMO.C is provided as an example of a way you might use evaluateExpression.
It parses an input file containing expressions and comments, evaluates the
expressions, and outputs the (final) value of each variable in the symbol table.
Note that the symbol table is alphabetically sorted. Since the output is in a form
which is itself readable by the parser, EVALDEMO could be easily modified to
accept previous output as initialization of the symbol table.
</P>
<P>
<BR>

<H3>Expression Syntax</H3>
<P>expressionString is a null terminated text string. It may contain any number
of expressions separated by commas or semicolons. White space may be used freely,
including both C and C++ style comments. Function calls may have any number of
arguments. </P>

<P>The expression syntax is borrowed from C but with the  addition of the
FORTRAN exponentiation operator (**).</P>
<P>
<BR>

<B>Examples:</B>
<PRE>   y1 = 21, LongVariableName = 12.5;  // simple assignment
   y1 += (1/(c=.05)) ;                // add to memory, with parenthesized assignment
   testx = x &gt;=z ? z : 1 ;            /* conditional expression */
   u = sin(x), v = cos(y);            // Standard math functions
</PRE>
EVALDEMO will accept the above lines as input either individually or together. See
the TEST file for further expression examples.

<P>
<BR>

<B>Operations:</B>

<P>The cast, increment, and decrement operators are not implemented, nor are
the following operations that are defined in C only for integers:</P>
<PRE>
    Bitwise logical operators:    &amp;, |, ^, ~, &amp;=, |=, ^=
    Remainder operators:          %, %=
    Shift operators:              &lt;&lt;, &gt;&gt;, &gt;&gt;=, &lt;&lt;=
</PRE>
<P>The supported operations are:  </P>
<PRE>
    Assignment operators:         =   +=   -=   *=   /=
    Conditional expressions:      ?  :
    Logical operators:            !  &amp;&amp;  ||
    Comparison operators:         ==  !=  &lt;  &lt;=  &gt;  &gt;=
    Binary arithmetic operators:  +  -  *  /
    Exponentiation:               **
    Unary arithmetic operators:   +  -
    Parentheses                   (  )
    Function calls                ...( ... )
</PRE>
<P>All arithmetic is double precision floating point.</P>
<P>
<BR>

<H3>Character Stack</H3>
<P> The parser presumes the existence of a character stack. The parser pushes
characters onto the stack by calling an externally defined function, </P>
<PRE>
    void pushChar(int c);
</PRE>
<P>To pass a character string to an external function (locateVariable, callFunction),
the parser pushes the
characters onto the stack and then provides the function with the length of the
string. It presumes the function will pop the characters from the stack.</P>
<P>
<BR>

<H3>Variables</H3>
<P>Variable names follow conventional C rules. The parser imposes no limits on
the length of variable names. There is no built in symbol recognition logic in
the parser module itself. To identify the location where the value of a variable
is stored, the parser calls </P>
<PRE>
    double *locateVariable(int nameLength);
</PRE>
<P>nameLength is the length of the variable name on the character stack.
locateVariable pops the name from the stack and returns a pointer to the value
of the variable.
<P/>
<P> <B>N.B. </B>If the name does not yet appear in the symbol table, the sample
implementation of locateVariable
adds it to the table and <B>initializes its value to zero.</B></P>
<P>
 The implementation of locateVariable provided in the wrapper module is intended
only as an example. Users with specific requirements might wish to modify it or
replace it with something more suitable to their needs.
</P>
<P>
<BR>

<H3>Function Calls</H3>
<P>Function names are not built into the parser, so that the user may
incorporate the functions he needs. When the parser encounters a function call,
it evaluates the arguments and calls an externally defined pushArg function to
save them on a stack, then invokes a callback function: </P>
<PRE>
    double callFunction(int nameLength, int argCount);
</PRE>
<P>to identify the function and evaluate it. The name of the function,
containing nameLength characters, is on the character stack, argCount specifies
the number of arguments on the the argument stack. callFunction must remove the
function name from the character stack and the arguments from the argument
stack.</P>
<P>The implementation of callFunction found in the wrapper module provides only
for the standard C library math functions. <B>Other functions can be added easily.</B></P>
<P>
<BR>

<H3>Return Value</H3>
<P>evaluateExpression returns 0 if there are no errors; otherwise it returns a
non-zero value.</P>

<HR>


<P>
<TABLE>
  <TR>
    <TD>
        <P>
        Parsifal Software <BR>
        P.O. Box 219<BR>
        Wayland, MA 01778
    </TD>
    <TD  WIDTH="100"><P> </P></TD>
    <TD VALIGN="BOTTOM" ALIGN="RIGHT">
       www.parsifalsoft.com<BR>
       1-800-879-2577<BR>
       Voice/Fax: 1-508-358-2564<BR>
    </TD>
  </TR>
</TABLE>
<HR>

<P>
<ADDRESS><FONT SIZE="-1">
                  AnaGram parser generator - examples<BR>
                  Copyright &copy; 1997 - 1999, Parsifal Software. <BR>
                  All Rights Reserved.<BR>
</FONT></ADDRESS>
<IMG ALIGN="right" SRC="pslrb6e.gif" ALT="Parsifal Software"
                WIDTH=181 HEIGHT=25>

<BR CLEAR="right">


Comments or questions?
<A HREF="mailto:support@parsifalsoft.com">support@parsifalsoft.com</A>


</BODY>
</HTML>

