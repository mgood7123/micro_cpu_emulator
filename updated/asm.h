/* A recursive-descent parser generated by peg 0.1.18 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
bool yyfrom_FILE=true;
#ifndef YY_FILESTREAM
#define YY_FILESTREAM	stdin
#endif
int    yy_FILE_string_pos = 0;
char * yy_FILE_string = NULL;
FILE * yy_FILE_file = NULL;
char get_char(void)
{
	if (yy_FILE_string[yy_FILE_string_pos] == 0) {
		return EOF;
	}
	else {
		yy_FILE_string_pos++;
		return yy_FILE_string[yy_FILE_string_pos-1];
	}
}

char unget_char() {
	if (yy_FILE_string_pos != 0) {
		yy_FILE_string_pos--;
		return yy_FILE_string[yy_FILE_string_pos];
	}
	else return EOF;
}

int getcharf(void) {
	if (yyfrom_FILE == true) return getchar();
	else return get_char();
}
int ungetcf(int c, FILE *stream) {
	if (yyfrom_FILE == true) return ungetc(c, stream);
	else return unget_char();
}

#define YYRULECOUNT 47
#line 405 "asm.leg"

	char * _STRING_ = "1+(1+1)+1";

#line 216 "asm.leg"

#define YY_CTX_LOCAL 1
#include <stdio.h>
struct asm_or_math {
	int value;
	char * name;
};
#define YYSTYPE struct asm_or_math
int vars[26];
int parser_opcode_count = 0;
int parser_opcode_error = 0;
char *** parser_table_encoding;
#define parser_opcode_type_number 1
#define parser_opcode_type_register 2
// yytext is undefined, this needs to be defined in order to create a function that uses yytext, a definition must be used instead
#define parser_opcode_parse(parser_opcode_parse_number, parser_opcode_parse_type) \
	if (!parser_opcode_error) { \
        if (parser_opcode_count == parser_opcode_parse_number) { \
            int isnum = 0; \
            char * desttype = NULL; \
            if (parser_opcode_parse_type == parser_opcode_type_number) desttype = "type_number"; \
			else if (parser_opcode_parse_type == parser_opcode_type_register) desttype = "type_register"; \
            char * type = env__get(*parser_table_encoding, desttype); \
            if (type) { \
				opcode_structure[internal_parser_index].opcode[parser_opcode_parse_number-1].type = *type; \
				pi(opcode_structure[internal_parser_index].opcode[parser_opcode_parse_number-1].type); \
			} else { \
                printf("error: invalid number token: %s\n", yytext); \
                opcode_structure[internal_parser_index].opcode[parser_opcode_parse_number-1].type = 0x0; \
                opcode_structure_clear(internal_parser_index); \
            } \
            if (parser_opcode_parse_type == parser_opcode_type_number) { \
				opcode_structure[internal_parser_index].opcode[parser_opcode_parse_number-1].opcode = atoi(yytext); \
				opcode_structure[internal_parser_index].opcode_count++; \
			} \
			else if (parser_opcode_parse_type == parser_opcode_type_register) { \
				char * operand; \
				operand = env__get(*parser_table_encoding, yytext+1); \
				opcode_structure[internal_parser_index].opcode[parser_opcode_parse_number-1].opcode = operand?(*operand):0x0; \
				opcode_structure[internal_parser_index].opcode_count++; \
			} \
        } \
    }

#ifndef REGEX_STR
int getbitgroupcount(int bit) {
	return snprintf(stdout, 0, "%d", bit);
}

struct regex_string_structure
{
	char * string;
	int index;
	int len;
	int malloced;
};

struct regex_string
{
	char * string;
	struct regex_string_structure escaped;
	struct regex_string_structure json;
	struct regex_string_structure c_define;
	int index;
	int len;
	int malloced;
};

#define str_malloc_(y, z) \
	y.string = malloc(z); \
	memset(y.string, 0, z); \
	y.malloced = z; \
	y.len = 0; \
	y.index = 0;

#define str_mallocr(y, z) \
	str_malloc_(y, z); \
	str_malloc_(y.escaped, z); \
	str_malloc_(y.json, z); \
	str_malloc_(y.c_define, z); \
	
#define str_malloc(y, z) \
	struct regex_string y; \
	str_mallocr(y, z);

#define str_new(str) \
	str_malloc(str, 1) \
	
#define str_free_(y) \
		memset(y.string, 0, y.malloced); \
		free(y.string); \
		y.string = NULL; \
		y.malloced = 0; \
		y.len = 0; \
		y.index = 0; \

#define str_free(y) \
	{ \
		str_free_(y); \
		str_free_(y.escaped); \
		str_free_(y.json); \
		str_free_(y.c_define); \
	}
	
#define str_reset_(str) { \
	str_free_(str) \
	str_malloc_(str, 1) \
}

#define str_reset(str) { \
	str_reset_(str) \
	str_reset_(str.escaped) \
	str_reset_(str.json) \
	str_reset_(str.c_define) \
}

#define str_realloc(y, z) \
	y.string = realloc(y.string, z); \
	if (y.malloced < z) { \
		memset(y.string+y.malloced, 0, y.malloced-z); \
	} \
	y.malloced = z;
	
#define str_info_(str) \
		printf("%s.index = %d\n", #str, str.index); \
		printf("%s.len = %d\n", #str, str.len); \
		printf("%s.malloced = %d\n", #str, str.malloced); \
		printf("%s.string = %s\n", #str, str.string); \

#define str_info(str) { \
	str_info_(str) \
	str_info_(str.escaped) \
	str_info_(str.json) \
	str_info_(str.c_define) \
}

#define str_insert_char(str, ch) { \
	str_realloc(str, str.malloced+2); \
	str.string[str.index] = ch; \
	str.index++; \
	str.string[str.index] = 0; \
	str.len = strlen(str.string); \
}

#define str_undo(str) { \
	str.index--; \
	str.string[str.index] = 0; \
	str_realloc(str, str.malloced-1); \
	str.len = strlen(str.string); \
}

#define rng(s, e) ( uch >= s && uch <= e)

#define str_insert_string(str, string) { \
	const unsigned char * s = string; \
	const unsigned int size = strlen(string); \
	int c; \
	unsigned char uch; \
	str_insert_char(str.c_define, '#') \
	str_insert_char(str.c_define, 'd') \
	str_insert_char(str.c_define, 'e') \
	str_insert_char(str.c_define, 'f') \
	str_insert_char(str.c_define, 'i') \
	str_insert_char(str.c_define, 'n') \
	str_insert_char(str.c_define, 'e') \
	str_insert_char(str.c_define, ' ') \
	int i; \
	for (i = 0; i < size; ++i) { \
		c = s[i]; \
		uch = (unsigned char) s[i]; \
		str_insert_char(str, c); \
		\
		/* escape sequences under gnu gcc are interperated by both cc1, and the terminal, assembling a string containing an invalid sequence will print as if it does not have the \ before it*/ \
		\
		if (isalnum(c) ) { \
			str_insert_char(str.c_define, c); \
		} \
		else str_insert_char(str.c_define, '_'); \
		if (c == '\a') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, 'a'); \
		} \
		else if (c == '\b') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, 'b'); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, 'b'); \
		} \
		else if (c == '\f') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, 'f'); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, 'f'); \
		} \
		else if (c == '\n') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, 'n'); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, 'n'); \
		} \
		else if (c == '\r') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, 'r'); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, 'r'); \
		} \
		else if (c == '\t') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, 't'); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, 't'); \
		} \
		else if (c == '\v') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, 'v'); \
		} \
		else if (c == '\\') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, '\\'); \
		} \
		else if (c == '\'') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, '\''); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, '\''); \
		} \
		else if (c == '"') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, '"'); \
			str_insert_char(str.json, '\\'); \
			str_insert_char(str.json, '"'); \
		} \
		else if (c == '\?') { \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, '?'); \
		} \
		else if (c >= ' ' && c <= 0x7e) { \
			str_insert_char(str.escaped, c); \
			str_insert_char(str.json, c); \
		} \
		else if (c >= '0' && c <= '9' ) { \
			/* Print \ooo */ \
			str_insert_char(str.escaped, '\\'); \
			str_insert_char(str.escaped, '0' + (c >> 6)); \
			str_insert_char(str.escaped, '0' + ((c >> 3) & 0x7)); \
			str_insert_char(str.escaped, '0' + (c & 0x7)); \
		} else { \
			/* Print \[[o]o]o */ \
			str_insert_char(str.escaped, '\\'); \
			if ((c >> 3) != 0) { \
				if ((c >> 6) != 0) str_insert_char(str.escaped, '0' + (c >> 6)); \
				str_insert_char(str.escaped, '0' + ((c >> 3) & 0x7)); \
			} \
			str_insert_char(str.escaped, '0' + (c & 0x7)); \
		} \
	} \
	str_insert_char(str.c_define, '\n'); \
}

#define str_int2string(x,y) \
	char * x = malloc(getbitgroupcount(y)); \
	sprintf(x, "%d", y);
	
#define str_insert_int(str, integer) { \
	str_int2string(j, integer); \
	str_insert_string(str, j); \
	free(j); \
}

int reverseBool(int val) {
	if (val == 1 || val == 0) return val^1;
	else return val;
}

void str_output(struct regex_string * str, const char * file);

void str_output_append(struct regex_string * str, const char * file);

#define str_output(str, file) { \
	FILE * stream = stdout; \
	int isfile = 0; \
	if (strcmp("stdin" file) == 0) stream = stdin; \
	else if(strcmp("stdout" file) == 0) stream = stdout; \
	else if(strcmp("stderr" file) == 0) stream = stderr; \
	else isfile = 1; \
	if (isfile) stream = fopen(file, "w"); \
	fwrite(str.string,str.len, 1, stream); \
	if (isfile) fclose(stream); \
}

#define str_output_append(str, file) { \
	FILE * stream = stdout; \
	int isfile = 0; \
	if (strcmp("stdin" file) == 0) stream = stdin; \
	else if(strcmp("stdout" file) == 0) stream = stdout; \
	else if(strcmp("stderr" file) == 0) stream = stderr; \
	else isfile = 1; \
	if (isfile) stream = fopen(file, "a"); \
	fwrite(str.string,str.len, 1, stream); \
	if (isfile) fclose(stream); \
}
#endif
#define PCRE2_CODE_UNIT_WIDTH 8

#include <stdio.h>
#include <string.h>
#include <pcre2.h>
#include <stdbool.h>

int regex(char * RegexStr, char * source)
{
	bool Found = false;
	pcre2_code *re;
	PCRE2_SPTR pattern;
	PCRE2_SPTR subject;
	int errornumber;
	int rc;
	PCRE2_SIZE erroroffset;
	PCRE2_SIZE *ovector;
	size_t subject_length;
	pcre2_match_data *match_data;
	
	pattern = (PCRE2_SPTR)RegexStr;// <<<<< This is where you pass your REGEX 
	subject = (PCRE2_SPTR)source;// <<<<< This is where you pass your bufer that will be checked. 
	subject_length = strlen((char *)subject);
	re = pcre2_compile (
	  pattern,               /* the pattern */
	  PCRE2_ZERO_TERMINATED, /* indicates pattern is zero-terminated */
	  0,                     /* default options */
	  &errornumber,          /* for error number */
	  &erroroffset,          /* for error offset */
	  NULL);                 /* use default compile context */
	
	/* Compilation failed: print the error message and exit. */
	if (re == NULL)
	{
	  PCRE2_UCHAR buffer[256];
	  pcre2_get_error_message(errornumber, buffer, sizeof(buffer));
	  printf("PCRE2 compilation failed at offset %d: %s\n", (int)erroroffset,buffer);
	  return 1;
	}
	
	
	match_data = pcre2_match_data_create_from_pattern(re, NULL);
	
	rc = pcre2_match(
	  re,
	  subject,              /* the subject string */
	  subject_length,       /* the length of the subject */
	  0,                    /* start at offset 0 in the subject */
	  0,                    /* default options */
	  match_data,           /* block for storing the result */
	  NULL);
  PCRE2_UCHAR ** list = NULL;
  PCRE2_SIZE * listlen = NULL;
  int rc2 = pcre2_substring_list_get(match_data, &list, &listlen);
  if(rc2 >=0  && rc >=0) {
    for (int i = 0; list[i]; i++) {
      printf("list[%d] = %s\n", i, list[i]);
      }
    }
  pcre2_match_data_free(match_data);   /* Release memory used for the match */
 	pcre2_code_free(re);
	return rc;
}

/* Author: mgood7123 (Matthew James Good) http://github.com/mgood7123 */
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

struct matched {
  char * match;
  int len;
  int start;
  int size;
};

#define matched_malloc_(y, z) { \
	y = malloc(sizeof(struct matched)*(z)); \
	memset(y, 0, sizeof(struct matched)*(z)); \
	y->size = (z); \
}

#define matched_malloc(y, z) \
	struct matched * y; \
	matched_malloc_(y, z);

#define matched_new(match) \
	matched_malloc(match, 1)

#define matched_free(y) { \
    for (int i = 0; i < y->size; i++) { \
      free(y[i].match); \
      y[i].len = 0; \
      y[i].start = 0; \
    }\
    y->size = 0; \
    free(y); \
}

#define matched_reset(match) { \
	matched_free(match) \
	matched_malloc_(match, 1) \
}

#define matched_realloc(y, z) { \
	y = realloc(y, sizeof(struct matched)*(z)); \
	if (y->size < sizeof(struct matched)*(z)) { \
		memset(y+y->size, 0, sizeof(struct matched)); \
	} \
	y->size = (z); \
}

#define matched_add(matched_match, matched_string, matched_len, matched_start) { \
  int matched_index = 0; \
	if (matched_match->match) { \
    matched_realloc(matched_match, matched_match->size+1); \
    matched_index = matched_match->size-1; \
  } \
	matched_match[matched_index].match = matched_string; \
	matched_match[matched_index].start = matched_start; \
	matched_match[matched_index].len = matched_len; \
}

#define matched_info_(matched_match, matched_i) { \
		printf("%s[%d].match = %s\n", #matched_match, matched_i, matched_match[i].match); \
		printf("%s[%d].len = %d\n", #matched_match, matched_i, matched_match[i].len); \
		printf("%s[%d].start = %d\n\n", #matched_match, matched_i, matched_match[i].start); \
}

#define matched_info(matched_match) { \
		printf("number of indexes in %s = %d\n", #matched_match, matched_match->size); \
		for (int i = 0; i < matched_match->size; i++) { \
      matched_info_(matched_match, i); \
    } \
}

int get_lines(char * file) {
  int p = 0, lines = 0;
  while(file[p]) {
    if(file[p] == '\n') lines++;
    p++;
  }
  if (lines == 0) lines = 1;
  return lines;
}

struct regex_string get_upto_x_lines(int line, char * file) {
  str_new(f);
  int p = 0, lines = 0, lines_total = 0, dest_line = 0;
  while(file[p]) {
    if (line == lines_total) dest_line = 1;
    str_insert_char(f, file[p]);
    if(file[p+1] == '\n') {
      if (dest_line) return f;
      lines++;
    }
    p++;
  }
  return f;
}

int calculate_correct_line_from_column(int column, char * file) {
  int p = 0, lines = 0, columns_total = 0;
  while(file[p]) {
    if(file[p] == '\n') {
      lines++;
    }
    columns_total++;
    if (column == columns_total) return lines;
    p++;
  }
  return -1;
}


int calculate_correct_column(int column, char * file) {
  int p = 0, lines = 0, columns = 0, columns_total = 0;
  while(file[p]) {
    columns++;
    if(file[p] == '\n') {
      lines++;
      columns = 0;
    }
    columns_total++;
    if (column == columns_total) return columns;
    p++;
  }
  return -1;
}



// pcre2demo man page

// Return to the PCRE2 index page.

// This page is part of the PCRE2 HTML documentation. It was generated automatically from the original man page. If there is any nonsense in it, please consult the man page, in case the conversion went wrong.

/*************************************************
*           PCRE2 DEMONSTRATION PROGRAM          *
*************************************************/

/* This is a demonstration program to illustrate a straightforward way of
using the PCRE2 regular expression library from a C program. See the
pcre2sample documentation for a short discussion ("man pcre2sample" if you have
the PCRE2 man pages installed). PCRE2 is a revised API for the library, and is
incompatible with the original PCRE API.

There are actually three libraries, each supporting a different code unit
width. This demonstration program uses the 8-bit library. The default is to
process each code unit as a separate character, but if the pattern begins with
"(*UTF)", both it and the subject are treated as UTF-8 strings, where
characters may occupy multiple code units.

In Unix-like environments, if PCRE2 is installed in your standard system
libraries, you should be able to compile this program using this command:

cc -Wall pcre2demo.c -lpcre2-8 -o pcre2demo

If PCRE2 is not installed in a standard place, it is likely to be installed
with support for the pkg-config mechanism. If you have pkg-config, you can
compile this program using this command:

cc -Wall pcre2demo.c `pkg-config --cflags --libs libpcre2-8` -o pcre2demo

If you do not have pkg-config, you may have to use something like this:

cc -Wall pcre2demo.c -I/usr/local/include -L/usr/local/lib \
  -R/usr/local/lib -lpcre2-8 -o pcre2demo

Replace "/usr/local/include" and "/usr/local/lib" with wherever the include and
library files for PCRE2 are installed on your system. Only some operating
systems (Solaris is one) use the -R option.

Building under Windows:

If you want to statically link this program against a non-dll .a file, you must
define PCRE2_STATIC before including pcre2.h, so in this environment, uncomment
the following line. */

/* #define PCRE2_STATIC */

/* The PCRE2_CODE_UNIT_WIDTH macro must be defined before including pcre2.h.
For a program that uses only one code unit width, setting it to 8, 16, or 32
makes it possible to use generic function names such as pcre2_compile(). Note
that just changing 8 to 16 (for example) is not sufficient to convert this
program to process 16-bit characters. Even in a fully 16-bit environment, where
string-handling functions such as strcmp() and printf() work with 16-bit
characters, the code for handling the table of named substrings will still need
to be modified. */

/**************************************************************************
* Here is the program. The API includes the concept of "contexts" for     *
* setting up unusual interface requirements for compiling and matching,   *
* such as custom memory managers and non-standard newline definitions.    *
* This program does not do any of this, so it makes no use of contexts,   *
* always passing NULL where a context could be given.                     *
**************************************************************************/

int regex_verbose2(PCRE2_SPTR pattern, PCRE2_SPTR subject, int find_all, struct matched ** m, bool verbose)
{
pcre2_code *re;
/* PCRE2_SPTR is a pointer to unsigned code units of */
/* the appropriate width (in this case, 8 bits). */
PCRE2_SPTR name_table;

int crlf_is_newline;
int errornumber;
int i;
int rc;
int utf8;

uint32_t option_bits;
uint32_t namecount;
uint32_t name_entry_size;
uint32_t newline;

PCRE2_SIZE erroroffset;
PCRE2_SIZE *ovector;

size_t subject_length;
pcre2_match_data *match_data;

str_new(f);
int column;
int line;




/**************************************************************************
* First, sort out the command line. There is only one possible option at  *
* the moment, "-g" to request repeated matching to find all occurrences,  *
* like Perl's /g option. We set the variable find_all to a non-zero value *
* if the -g option is present.                                            *
**************************************************************************/

/* After the options, we require exactly two arguments, which are the pattern,
and the subject string. */

/* As pattern and subject are char arguments, they can be straightforwardly
cast to PCRE2_SPTR as we are working in 8-bit code units. */

subject_length = strlen((char *)subject);


/*************************************************************************
* Now we are going to compile the regular expression pattern, and handle *
* any errors that are detected.                                          *
*************************************************************************/

re = pcre2_compile(
  pattern,               /* the pattern */
  PCRE2_ZERO_TERMINATED, /* indicates pattern is zero-terminated */
  0,                     /* default options */
  &errornumber,          /* for error number */
  &erroroffset,          /* for error offset */
  NULL);                 /* use default compile context */

/* Compilation failed: print the error message and exit. */

if (re == NULL)
  {
  PCRE2_UCHAR buffer[256];
  pcre2_get_error_message(errornumber, buffer, sizeof(buffer));
  if (verbose == true) printf("PCRE2 compilation failed at offset %d: %s\n", (int)erroroffset,
    buffer);
  return 1;
  }


/*************************************************************************
* If the compilation succeeded, we call PCRE again, in order to do a     *
* pattern match against the subject string. This does just ONE match. If *
* further matching is needed, it will be done below. Before running the  *
* match we must set up a match_data block for holding the result.        *
*************************************************************************/

/* Using this function ensures that the block is exactly the right size for
the number of capturing parentheses in the pattern. */

match_data = pcre2_match_data_create_from_pattern(re, NULL);

rc = pcre2_match(
  re,                   /* the compiled pattern */
  subject,              /* the subject string */
  subject_length,       /* the length of the subject */
  0,                    /* start at offset 0 in the subject */
  0,                    /* default options */
  match_data,           /* block for storing the result */
  NULL);                /* use default match context */

/* Matching failed: handle error cases */

if (rc < 0)
  {
  if (verbose == true) switch(rc)
    {
    case PCRE2_ERROR_NOMATCH: printf("No match\n"); break;
    /*
    Handle other special cases if you like
    */
    default: printf("Matching error %d\n", rc); break;
    }
  pcre2_match_data_free(match_data);   /* Release memory used for the match */
  pcre2_code_free(re);                 /* data and the compiled pattern. */
  return 1;
  }

/* Match succeeded. Get a pointer to the output vector, where string offsets are
stored. */
ovector = pcre2_get_ovector_pointer(match_data);
if (!m) {
  column = calculate_correct_column((int)ovector[0]+1, subject);
  line = calculate_correct_line_from_column((int)ovector[0]+1, subject);
  f = get_upto_x_lines(line, subject);
  if (verbose == true) printf("Match succeeded at offset %d\n", (int)ovector[0]);
  if (verbose == true) printf("%s\n%*c\n", f.string, column, '^');
  str_reset(f);
}
/*************************************************************************
* We have found the first match within the subject string. If the output *
* vector wasn't big enough, say so. Then output any substrings that were *
* captured.                                                              *
*************************************************************************/

/* The output vector wasn't big enough. This should not happen, because we used
pcre2_match_data_create_from_pattern() above. */

if (rc == 0)
  if (verbose == true) printf("ovector was not big enough for all the captured substrings\n");

/* We must guard against patterns such as /(?=.\K)/ that use \K in an assertion
to set the start of a match later than its end. In this demonstration program,
we just detect this case and give up. */

if (ovector[0] > ovector[1])
  {
  if (verbose == true) printf("\\K was used in an assertion to set the match start after its end.\n"
    "From end to start the match was: %.*s\n", (int)(ovector[0] - ovector[1]),
      (char *)(subject + ovector[1]));
  if (verbose == true) printf("Run abandoned\n");
  pcre2_match_data_free(match_data);
  pcre2_code_free(re);
  str_free(f);
  return 1;
  }

/* Show substrings stored in the output vector by number. Obviously, in a real
application you might want to do things other than print them. */

for (i = 0; i < rc; i++)
  {
  PCRE2_SPTR substring_start = subject + ovector[2*i];
  size_t substring_length = ovector[2*i+1] - ovector[2*i];
  if (m) {
    str_new(match);
    for (int ii = 0; ii < (int)substring_length; ii++)
      str_insert_char(match, substring_start[ii]);
    matched_add((*m), strdup(match.string), (int)substring_length, ovector[2*i]);
    str_free(match);
  } else if (verbose == true) printf("%2d: %.*s\n", i, (int)substring_length, (char *)substring_start);
  }


/**************************************************************************
* That concludes the basic part of this demonstration program. We have    *
* compiled a pattern, and performed a single match. The code that follows *
* shows first how to access named substrings, and then how to code for    *
* repeated matches on the same subject.                                   *
**************************************************************************/

/* See if there are any named substrings, and if so, show them by name. First
we have to extract the count of named parentheses from the pattern. */

(void)pcre2_pattern_info(
  re,                   /* the compiled pattern */
  PCRE2_INFO_NAMECOUNT, /* get the number of named substrings */
  &namecount);          /* where to put the answer */

if (namecount != 0)
  {
  PCRE2_SPTR tabptr;
  if (verbose == true) printf("Named substrings\n");

  /* Before we can access the substrings, we must extract the table for
  translating names to numbers, and the size of each entry in the table. */

  (void)pcre2_pattern_info(
    re,                       /* the compiled pattern */
    PCRE2_INFO_NAMETABLE,     /* address of the table */
    &name_table);             /* where to put the answer */

  (void)pcre2_pattern_info(
    re,                       /* the compiled pattern */
    PCRE2_INFO_NAMEENTRYSIZE, /* size of each entry in the table */
    &name_entry_size);        /* where to put the answer */

  /* Now we can scan the table and, for each entry, print the number, the name,
  and the substring itself. In the 8-bit library the number is held in two
  bytes, most significant first. */

  tabptr = name_table;
  for (i = 0; i < namecount; i++)
    {
    int n = (tabptr[0] << 8) | tabptr[1];
    if (verbose == true) printf("(%d) %*s: %.*s\n", n, name_entry_size - 3, tabptr + 2,
      (int)(ovector[2*n+1] - ovector[2*n]), subject + ovector[2*n]);
    tabptr += name_entry_size;
    }
  }


/*************************************************************************
* If the "-g" option was given on the command line, we want to continue  *
* to search for additional matches in the subject string, in a similar   *
* way to the /g option in Perl. This turns out to be trickier than you   *
* might think because of the possibility of matching an empty string.    *
* What happens is as follows:                                            *
*                                                                        *
* If the previous match was NOT for an empty string, we can just start   *
* the next match at the end of the previous one.                         *
*                                                                        *
* If the previous match WAS for an empty string, we can't do that, as it *
* would lead to an infinite loop. Instead, a call of pcre2_match() is    *
* made with the PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED flags set. The *
* first of these tells PCRE2 that an empty string at the start of the    *
* subject is not a valid match; other possibilities must be tried. The   *
* second flag restricts PCRE2 to one match attempt at the initial string *
* position. If this match succeeds, an alternative to the empty string   *
* match has been found, and we can print it and proceed round the loop,  *
* advancing by the length of whatever was found. If this match does not  *
* succeed, we still stay in the loop, advancing by just one character.   *
* In UTF-8 mode, which can be set by (*UTF) in the pattern, this may be  *
* more than one byte.                                                    *
*                                                                        *
* However, there is a complication concerned with newlines. When the     *
* newline convention is such that CRLF is a valid newline, we must       *
* advance by two characters rather than one. The newline convention can  *
* be set in the regex by (*CR), etc.; if not, we must find the default.  *
*************************************************************************/

if (!find_all)     /* Check for -g */
  {
  pcre2_match_data_free(match_data);  /* Release the memory that was used */
  pcre2_code_free(re);                /* for the match data and the pattern. */
  str_free(f);
  return 0;                           /* Exit the program. */
  }

/* Before running the loop, check for UTF-8 and whether CRLF is a valid newline
sequence. First, find the options with which the regex was compiled and extract
the UTF state. */

(void)pcre2_pattern_info(re, PCRE2_INFO_ALLOPTIONS, &option_bits);
utf8 = (option_bits & PCRE2_UTF) != 0;

/* Now find the newline convention and see whether CRLF is a valid newline
sequence. */

(void)pcre2_pattern_info(re, PCRE2_INFO_NEWLINE, &newline);
crlf_is_newline = newline == PCRE2_NEWLINE_ANY ||
                  newline == PCRE2_NEWLINE_CRLF ||
                  newline == PCRE2_NEWLINE_ANYCRLF;

/* Loop for second and subsequent matches */

for (;;)
  {
  uint32_t options = 0;                   /* Normally no options */
  PCRE2_SIZE start_offset = ovector[1];   /* Start at end of previous match */

  /* If the previous match was for an empty string, we are finished if we are
  at the end of the subject. Otherwise, arrange to run another match at the
  same point to see if a non-empty match can be found. */

  if (ovector[0] == ovector[1])
    {
    if (ovector[0] == subject_length) break;
    options = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;
    }

  /* If the previous match was not an empty string, there is one tricky case to
  consider. If a pattern contains \K within a lookbehind assertion at the
  start, the end of the matched string can be at the offset where the match
  started. Without special action, this leads to a loop that keeps on matching
  the same substring. We must detect this case and arrange to move the start on
  by one character. The pcre2_get_startchar() function returns the starting
  offset that was passed to pcre2_match(). */

  else
    {
    PCRE2_SIZE startchar = pcre2_get_startchar(match_data);
    if (start_offset <= startchar)
      {
      if (startchar >= subject_length) break;   /* Reached end of subject.   */
      start_offset = startchar + 1;             /* Advance by one character. */
      if (utf8)                                 /* If UTF-8, it may be more  */
        {                                       /*   than one code unit.     */
        for (; start_offset < subject_length; start_offset++)
          if ((subject[start_offset] & 0xc0) != 0x80) break;
        }
      }
    }

  /* Run the next matching operation */

  rc = pcre2_match(
    re,                   /* the compiled pattern */
    subject,              /* the subject string */
    subject_length,       /* the length of the subject */
    start_offset,         /* starting offset in the subject */
    options,              /* options */
    match_data,           /* block for storing the result */
    NULL);                /* use default match context */

  /* This time, a result of NOMATCH isn't an error. If the value in "options"
  is zero, it just means we have found all possible matches, so the loop ends.
  Otherwise, it means we have failed to find a non-empty-string match at a
  point where there was a previous empty-string match. In this case, we do what
  Perl does: advance the matching position by one character, and continue. We
  do this by setting the "end of previous match" offset, because that is picked
  up at the top of the loop as the point at which to start again.

  There are two complications: (a) When CRLF is a valid newline sequence, and
  the current position is just before it, advance by an extra byte. (b)
  Otherwise we must ensure that we skip an entire UTF character if we are in
  UTF mode. */

  if (rc == PCRE2_ERROR_NOMATCH)
    {
    if (options == 0) break;                    /* All matches found */
    ovector[1] = start_offset + 1;              /* Advance one code unit */
    if (crlf_is_newline &&                      /* If CRLF is a newline & */
        start_offset < subject_length - 1 &&    /* we are at CRLF, */
        subject[start_offset] == '\r' &&
        subject[start_offset + 1] == '\n')
      ovector[1] += 1;                          /* Advance by one more. */
    else if (utf8)                              /* Otherwise, ensure we */
      {                                         /* advance a whole UTF-8 */
      while (ovector[1] < subject_length)       /* character. */
        {
        if ((subject[ovector[1]] & 0xc0) != 0x80) break;
        ovector[1] += 1;
        }
      }
    continue;    /* Go round the loop again */
    }

  /* Other matching errors are not recoverable. */

  if (rc < 0)
    {
    if (verbose == true) printf("Matching error %d\n", rc);
    pcre2_match_data_free(match_data);
    pcre2_code_free(re);
    str_free(f);
    return 1;
    }

  /* Match succeeded */
  if (!m) {
    column = calculate_correct_column((int)ovector[0]+1, subject);
    line = calculate_correct_line_from_column((int)ovector[0]+1, subject);
    f = get_upto_x_lines(line, subject);
    if (verbose == true) printf("Match succeeded again at offset %d\n", (int)ovector[0]);
    if (verbose == true) printf("%s\n%*c\n", f.string, column, '^');
    str_reset(f);
  }


  /* The match succeeded, but the output vector wasn't big enough. This
  should not happen. */

  if (rc == 0)
    if (verbose == true) printf("ovector was not big enough for all the captured substrings\n");

  /* We must guard against patterns such as /(?=.\K)/ that use \K in an
  assertion to set the start of a match later than its end. In this
  demonstration program, we just detect this case and give up. */

  if (ovector[0] > ovector[1])
    {
    if (verbose == true) printf("\\K was used in an assertion to set the match start after its end.\n"
      "From end to start the match was: %.*s\n", (int)(ovector[0] - ovector[1]),
        (char *)(subject + ovector[1]));
    if (verbose == true) printf("Run abandoned\n");
    pcre2_match_data_free(match_data);
    pcre2_code_free(re);
    str_free(f);
    return 1;
    }

  /* As before, show substrings stored in the output vector by number, and then
  also any named substrings. */

  for (i = 0; i < rc; i++)
    {
    PCRE2_SPTR substring_start = subject + ovector[2*i];
    size_t substring_length = ovector[2*i+1] - ovector[2*i];
    if (m) {
      str_new(match);
      for (int ii = 0; ii < (int)substring_length; ii++)
        str_insert_char(match, substring_start[ii]);
      matched_add((*m), strdup(match.string), (int)substring_length, ovector[2*i]);
      str_free(match);
    } else if (verbose == true) printf("%2d: %.*s\n", i, (int)substring_length, (char *)substring_start);
    }

  if (namecount != 0)
    {
    PCRE2_SPTR tabptr = name_table;
    if (verbose == true) printf("Named substrings\n");
    for (i = 0; i < namecount; i++)
      {
      int n = (tabptr[0] << 8) | tabptr[1];
      if (verbose == true) printf("(%d) %*s: %.*s\n", n, name_entry_size - 3, tabptr + 2,
        (int)(ovector[2*n+1] - ovector[2*n]), subject + ovector[2*n]);
      tabptr += name_entry_size;
      }
    }
  }      /* End of loop to find second and subsequent matches */

pcre2_match_data_free(match_data);
pcre2_code_free(re);
str_free(f);
return 0;
}

/* End of pcre2demo.c */


// Return to the PCRE2 index page.


int   yydebug = 0;
int   yylineNumber = 0;
#ifndef YY_MALLOC
#define YY_MALLOC(C, N)		malloc(N)
#endif
#ifndef YY_REALLOC
#define YY_REALLOC(C, P, N)	realloc(P, N)
#endif
#ifndef YY_FREE
#define YY_FREE(C, P)		free(P)
#endif
#ifndef YY_LOCAL
#define YY_LOCAL(T)	static T
#endif
#ifndef YY_ACTION
#define YY_ACTION(T)	static T
#endif
#ifndef YY_RULE
#define YY_RULE(T)	static T
#endif
#ifndef YY_PARSE
#define YY_PARSE(T)	T
#endif
#ifndef YYPARSE
#define YYPARSE		yyparse
#endif
#ifndef YYPARSEFROM
#define YYPARSEFROM	yyparsefrom
#endif
#ifndef YYRELEASE
#define YYRELEASE	yyrelease
#endif
#ifndef YY_BEGIN
#define YY_BEGIN	( yy->__begin= yy->__pos, 1)
#endif
#ifndef YY_END
#define YY_END		( yy->__end= yy->__pos, 1)
#endif
# define yyprintf(args)	{ if (yydebug) fprintf args; }
#ifndef YYSTYPE
#define YYSTYPE	int
#endif
#ifndef YY_STACK_SIZE
#define YY_STACK_SIZE 128
#endif

#ifndef YY_BUFFER_SIZE
#define YY_BUFFER_SIZE 1024
#endif

#ifndef YY_PART

typedef struct _yycontext yycontext;
typedef void (*yyaction)(yycontext *yy, char *yytext, int yyleng);
typedef struct _yythunk { int begin, end;  yyaction  action;  struct _yythunk *next; } yythunk;

struct _yycontext {
  char     *__buf;
  int       __buflen;
  int       __pos;
  int       __pos2;
  int       __limit;
  char     *__text;
  int       __textlen;
  int       __begin;
  int       __end;
  int       __textmax;
  yythunk  *__thunks;
  int       __thunkslen;
  int       __thunkpos;
  YYSTYPE   __;
  YYSTYPE  *__val;
  YYSTYPE  *__vals;
  int       __valslen;
#ifdef YY_CTX_MEMBERS
  YY_CTX_MEMBERS
#endif
};

#ifdef YY_CTX_LOCAL
#define YY_CTX_PARAM_	yycontext *yyctx,
#define YY_CTX_PARAM	yycontext *yyctx
#define YY_CTX_ARG_	yyctx,
#define YY_CTX_ARG	yyctx
#ifndef YY_INPUT
#define YY_INPUT(yy, buf, result, max_size)		\
  {							\
    int yyc= getcharf();					\
    if (yy) yy->__pos2++;\
    if ('\n' == yyc || '\r' == yyc) ++yylineNumber;	\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#else
#define YY_CTX_PARAM_
#define YY_CTX_PARAM
#define YY_CTX_ARG_
#define YY_CTX_ARG
yycontext _yyctx= { 0, 0, 0, 0 };
yycontext *yyctx= &_yyctx;
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)			\
  {							\
    int yyc= getcharf();					\
    if (yyctx) yyctx->__pos2++;\
    if ('\n' == yyc || '\r' == yyc) ++yylineNumber;	\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#endif

YY_LOCAL(int) yyrefill(yycontext *yy)
{
  int yyn;
  while (yy->__buflen - yy->__pos < 512)
    {
      yy->__buflen *= 2;
      yy->__buf= (char *)YY_REALLOC(yy, yy->__buf, yy->__buflen);
    }
#ifdef YY_CTX_LOCAL
  YY_INPUT(yy, (yy->__buf + yy->__pos), yyn, (yy->__buflen - yy->__pos));
#else
  YY_INPUT((yy->__buf + yy->__pos), yyn, (yy->__buflen - yy->__pos));
#endif
  if (!yyn) return 0;
  yy->__limit += yyn;
  return 1;
}

YY_LOCAL(int) yymatchDot(yycontext *yy)
{
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  ++yy->__pos;
  return 1;
}

YY_LOCAL(int) yymatchChar(yycontext *yy, int c)
{
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  if ((unsigned char)yy->__buf[yy->__pos] == c)
    {
      ++yy->__pos;
      yyprintf((stderr, "  ok   yymatchChar(yy, %c) @ %s\n", c, yy->__buf+yy->__pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchChar(yy, %c) @ %s\n", c, yy->__buf+yy->__pos));
  return 0;
}

YY_LOCAL(int) yymatchString(yycontext *yy, const char *s)
{
  int yysav= yy->__pos;
  while (*s)
    {
      if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
      if (yy->__buf[yy->__pos] != *s)
        {
          yy->__pos= yysav;
          return 0;
        }
      ++s;
      ++yy->__pos;
    }
  return 1;
}

YY_LOCAL(int) yymatchClass(yycontext *yy, unsigned char *bits)
{
  int c;
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  c= (unsigned char)yy->__buf[yy->__pos];
  if (bits[c >> 3] & (1 << (c & 7)))
    {
      ++yy->__pos;
      yyprintf((stderr, "  ok   yymatchClass @ %s\n", yy->__buf+yy->__pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchClass @ %s\n", yy->__buf+yy->__pos));
  return 0;
}

YY_LOCAL(int) yymatchRegex(yycontext *yy, unsigned char *bits)
{
  str_new(save);
  char * ch = malloc(2);
  ch[0] = 0; ch[1] = 0;
  while((ch[0] = getcharf()) != EOF) str_insert_string(save, ch);
  free(ch);
  if (yydebug) printf("looked ahead to grab '%s' from stdin\n", save.json.string);
  char * string = strdup(save.string);
  while(save.len) {
    ungetcf(save.string[save.len-1], stdin);
    str_undo(save);
  }
  str_free(save);
  matched_new(m);
  int ret = 0;
  if (regex_verbose2(bits, string, 1, &m, false) != 1) {
    if (yydebug) matched_info(m);
    ret = 1;
    for (int i = 0; i < m->len; i++) {
      if (!yyrefill(yy)) break;
      ++yy->__pos;
    }
    if (m->len != 1) yyrefill(yy);
  } else ret = 0;
  matched_free(m);
  free(string);
  yyprintf((stderr, "  %s yymatchRegex @ %s\n", ret==0?"ok":"fail", yy->__buf+yy->__pos));
  return ret;
}

YY_LOCAL(void) yyDo(yycontext *yy, yyaction action, int begin, int end)
{
  while (yy->__thunkpos >= yy->__thunkslen)
    {
      yy->__thunkslen *= 2;
      yy->__thunks= (yythunk *)YY_REALLOC(yy, yy->__thunks, sizeof(yythunk) * yy->__thunkslen);
    }
  yy->__thunks[yy->__thunkpos].begin=  begin;
  yy->__thunks[yy->__thunkpos].end=    end;
  yy->__thunks[yy->__thunkpos].action= action;
  ++yy->__thunkpos;
}

YY_LOCAL(int) yyText(yycontext *yy, int begin, int end)
{
  int yyleng= end - begin;
  if (yyleng <= 0)
    yyleng= 0;
  else
    {
      while (yy->__textlen < (yyleng + 1))
	{
	  yy->__textlen *= 2;
	  yy->__text= (char *)YY_REALLOC(yy, yy->__text, yy->__textlen);
	}
      memcpy(yy->__text, yy->__buf + begin, yyleng);
    }
  yy->__text[yyleng]= '\0';
  return yyleng;
}

YY_LOCAL(void) yyDone(yycontext *yy)
{
  int pos;
  for (pos= 0;  pos < yy->__thunkpos;  ++pos)
    {
      yythunk *thunk= &yy->__thunks[pos];
      int yyleng= thunk->end ? yyText(yy, thunk->begin, thunk->end) : thunk->begin;
      yyprintf((stderr, "DO [%d] %p %s\n", pos, thunk->action, yy->__text));
      thunk->action(yy, yy->__text, yyleng);
    }
  yy->__thunkpos= 0;
}

YY_LOCAL(void) yyCommit(yycontext *yy)
{
  if ((yy->__limit -= yy->__pos))
    {
      memmove(yy->__buf, yy->__buf + yy->__pos, yy->__limit);
    }
  yy->__begin -= yy->__pos;
  yy->__end -= yy->__pos;
  yy->__pos= yy->__thunkpos= 0;
}

YY_LOCAL(int) yyAccept(yycontext *yy, int tp0)
{
  if (tp0)
    {
      fprintf(stderr, "accept denied at %d\n", tp0);
      return 0;
    }
  else
    {
      yyDone(yy);
      yyCommit(yy);
    }
  return 1;
}

YY_LOCAL(void) yyPush(yycontext *yy, char *text, int count)
{
  yy->__val += count;
  while (yy->__valslen <= yy->__val - yy->__vals)
    {
      long offset= yy->__val - yy->__vals;
      yy->__valslen *= 2;
      yy->__vals= (YYSTYPE *)YY_REALLOC(yy, yy->__vals, sizeof(YYSTYPE) * yy->__valslen);
      yy->__val= yy->__vals + offset;
    }
}
YY_LOCAL(void) yyPop(yycontext *yy, char *text, int count)   { yy->__val -= count; }
YY_LOCAL(void) yySet(yycontext *yy, char *text, int count)   { yy->__val[count]= yy->__; }

#endif /* YY_PART */

#define	YYACCEPT	yyAccept(yy, yythunkpos0)

YY_RULE(int) yy_subt(yycontext *yy); /* 47 */
YY_RULE(int) yy_val(yycontext *yy); /* 46 */
YY_RULE(int) yy_expr(yycontext *yy); /* 45 */
YY_RULE(int) yy_true_or_false(yycontext *yy); /* 44 */
YY_RULE(int) yy_CLOSE(yycontext *yy); /* 43 */
YY_RULE(int) yy_OPEN(yycontext *yy); /* 42 */
YY_RULE(int) yy_NUMBER(yycontext *yy); /* 41 */
YY_RULE(int) yy_DIVIDE(yycontext *yy); /* 40 */
YY_RULE(int) yy_TIMES(yycontext *yy); /* 39 */
YY_RULE(int) yy_Value(yycontext *yy); /* 38 */
YY_RULE(int) yy_MINUS(yycontext *yy); /* 37 */
YY_RULE(int) yy_PLUS(yycontext *yy); /* 36 */
YY_RULE(int) yy_Product(yycontext *yy); /* 35 */
YY_RULE(int) yy_Sum(yycontext *yy); /* 34 */
YY_RULE(int) yy_ASSIGN(yycontext *yy); /* 33 */
YY_RULE(int) yy_ID(yycontext *yy); /* 32 */
YY_RULE(int) yy_Expr(yycontext *yy); /* 31 */
YY_RULE(int) yy_Stmt(yycontext *yy); /* 30 */
YY_RULE(int) yy_MATH_SEPERATOR(yycontext *yy); /* 29 */
YY_RULE(int) yy_MATH_EQUALS(yycontext *yy); /* 28 */
YY_RULE(int) yy_MATH_OPEN(yycontext *yy); /* 27 */
YY_RULE(int) yy_MATH_CLOSE(yycontext *yy); /* 26 */
YY_RULE(int) yy_MATH_op(yycontext *yy); /* 25 */
YY_RULE(int) yy_MATH_word(yycontext *yy); /* 24 */
YY_RULE(int) yy_exp(yycontext *yy); /* 23 */
YY_RULE(int) yy_expression(yycontext *yy); /* 22 */
YY_RULE(int) yy_s_qword(yycontext *yy); /* 21 */
YY_RULE(int) yy_s_dword(yycontext *yy); /* 20 */
YY_RULE(int) yy_s_word(yycontext *yy); /* 19 */
YY_RULE(int) yy_s_byte(yycontext *yy); /* 18 */
YY_RULE(int) yy_comma(yycontext *yy); /* 17 */
YY_RULE(int) yy_reg(yycontext *yy); /* 16 */
YY_RULE(int) yy_number(yycontext *yy); /* 15 */
YY_RULE(int) yy_REG__(yycontext *yy); /* 14 */
YY_RULE(int) yy_NUM__(yycontext *yy); /* 13 */
YY_RULE(int) yy_word(yycontext *yy); /* 12 */
YY_RULE(int) yy_register_token(yycontext *yy); /* 11 */
YY_RULE(int) yy_something(yycontext *yy); /* 10 */
YY_RULE(int) yy_EOF(yycontext *yy); /* 9 */
YY_RULE(int) yy_EOL(yycontext *yy); /* 8 */
YY_RULE(int) yy_operands(yycontext *yy); /* 7 */
YY_RULE(int) yy__(yycontext *yy); /* 6 */
YY_RULE(int) yy_se(yycontext *yy); /* 5 */
YY_RULE(int) yy_size(yycontext *yy); /* 4 */
YY_RULE(int) yy_ss(yycontext *yy); /* 3 */
YY_RULE(int) yy_instruction(yycontext *yy); /* 2 */
YY_RULE(int) yy_asm(yycontext *yy); /* 1 */

YY_ACTION(void) yy_2_val(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_val\n"));
  {
#line 430 
   __.value = 1; __.name = "true"; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_val(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_val\n"));
  {
#line 428 
   __.value = 0; __.name = "true"; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_subt(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_subt\n"));
  {
#line 425 
   puts("sub expression leave"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_subt(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_subt\n"));
  {
#line 423 
   puts("sub expression enter"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_10_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_10_expr\n"));
  {
#line 419 
   __.value = lv.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_9_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_9_expr\n"));
  {
#line 418 
   printf("( prev: %d ", lv.value); lv.value /= rv.value; printf("new %d )\n", lv.value); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_8_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_8_expr\n"));
  {
#line 418 
   printf("divide %s "	, rv.name); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_7_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_expr\n"));
  {
#line 417 
   printf("( prev: %d ", lv.value); lv.value *= rv.value; printf("new %d )\n", lv.value); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_6_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_expr\n"));
  {
#line 417 
   printf("multiply %s "	, rv.name); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_5_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_expr\n"));
  {
#line 416 
   printf("( prev: %d ", lv.value); lv.value -= rv.value; printf("new %d )\n", lv.value); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_4_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_expr\n"));
  {
#line 416 
   printf("minus %s "		, rv.name); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_3_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_expr\n"));
  {
#line 415 
   printf("( prev: %d ", lv.value); lv.value += rv.value; printf("new %d )\n", lv.value); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_2_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_expr\n"));
  {
#line 415 
   printf("add %s "		, rv.name); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_1_expr(yycontext *yy, char *yytext, int yyleng)
{
#define rv yy->__val[-1]
#define lv yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_expr\n"));
  {
#line 412 
   printf("%s\n", lv.name); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rv
#undef lv
}
YY_ACTION(void) yy_1_true_or_false(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_true_or_false\n"));
  {
#line 409 
   printf("equals %d\n", e.value); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_1_ID(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ID\n"));
  {
#line 357 
   __.value= yytext[0] - 'a'; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_NUMBER(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_NUMBER\n"));
  {
#line 356 
   __.value= atoi(yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_3_Value(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_Value\n"));
  {
#line 354 
   __.value= i.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
}
YY_ACTION(void) yy_2_Value(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_Value\n"));
  {
#line 353 
   __.value= vars[i.value]; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
}
YY_ACTION(void) yy_1_Value(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_Value\n"));
  {
#line 352 
   __.value= atoi(yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
}
YY_ACTION(void) yy_3_Product(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define l yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_Product\n"));
  {
#line 350 
   __.value= l.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef l
}
YY_ACTION(void) yy_2_Product(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define l yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_Product\n"));
  {
#line 349 
   l.value /= r.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef l
}
YY_ACTION(void) yy_1_Product(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define l yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_Product\n"));
  {
#line 348 
   l.value *= r.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef l
}
YY_ACTION(void) yy_3_Sum(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define l yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_Sum\n"));
  {
#line 345 
   __.value= l.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef l
}
YY_ACTION(void) yy_2_Sum(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define l yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_Sum\n"));
  {
#line 344 
   l.value -= r.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef l
}
YY_ACTION(void) yy_1_Sum(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define l yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_Sum\n"));
  {
#line 343 
   l.value += r.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef l
}
YY_ACTION(void) yy_2_Expr(yycontext *yy, char *yytext, int yyleng)
{
#define s yy->__val[-1]
#define i yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_Expr\n"));
  {
#line 340 
   __.value= s.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef s
#undef i
}
YY_ACTION(void) yy_1_Expr(yycontext *yy, char *yytext, int yyleng)
{
#define s yy->__val[-1]
#define i yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_Expr\n"));
  {
#line 339 
   __.value= vars[i.value]= s.value; ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef s
#undef i
}
YY_ACTION(void) yy_2_Stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_Stmt\n"));
  {
#line 337 
   printf("error\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_1_Stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_Stmt\n"));
  {
#line 336 
   printf("%d\n", e); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_2_MATH_SEPERATOR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_MATH_SEPERATOR\n"));
  {
#line 334 
   printf("SEPERATOR: [EOF] "); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MATH_SEPERATOR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MATH_SEPERATOR\n"));
  {
#line 334 
   printf("SEPERATOR: [%s] ",yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MATH_CLOSE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MATH_CLOSE\n"));
  {
#line 333 
   printf("CLOSE: [%s] ",yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MATH_OPEN(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MATH_OPEN\n"));
  {
#line 332 
   printf("OPEN: [%s] ",yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MATH_EQUALS(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MATH_EQUALS\n"));
  {
#line 331 
   printf("EQUALS: [%s] ",yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MATH_word(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MATH_word\n"));
  {
#line 330 
   printf("word: [%s] ",yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MATH_op(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MATH_op\n"));
  {
#line 329 
   printf("op: [%s] ",yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_exp(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_exp\n"));
  {
#line 327 
   printf("error\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_exp(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_exp\n"));
  {
#line 326 
   printf("expression end\n\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_s_qword(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_s_qword\n"));
  {
#line 307 
   printf("size: qword (8)\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_s_dword(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_s_dword\n"));
  {
#line 306 
   printf("size: dword (4)\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_s_word(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_s_word\n"));
  {
#line 305 
   printf("size: word (2)\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_s_byte(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_s_byte\n"));
  {
#line 304 
   printf("size: byte (1)\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_REG__(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_REG__\n"));
  {
#line 293 
  
	parser_opcode_count++;
	pi(parser_opcode_count);
	parser_opcode_parse(1, parser_opcode_type_register);
	parser_opcode_parse(2, parser_opcode_type_register);
	parser_opcode_parse(3, parser_opcode_type_register);
;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_NUM__(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_NUM__\n"));
  {
#line 285 
  
	parser_opcode_count++;
	pi(parser_opcode_count);
	parser_opcode_parse(1, parser_opcode_type_number);
	parser_opcode_parse(2, parser_opcode_type_number);
	parser_opcode_parse(3, parser_opcode_type_number);
;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_asm(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_asm\n"));
  {
#line 276 
   printf("error\n"); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}

YY_RULE(int) yy_subt(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "subt"));
  if (!yymatchChar(yy, '('))  {
  goto l1;
  }
  yyDo(yy, yy_1_subt, yy->__begin, yy->__end);
  if (!yy_true_or_false(yy))   {
  goto l1;
  }
  if (!yymatchChar(yy, ')'))  {
  goto l1;
  }
  yyDo(yy, yy_2_subt, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "subt", yy->__buf+yy->__pos));
  return 1;
  l1:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "subt", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_val(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "val"));
  {
  int yypos3= yy->__pos, yythunkpos3= yy->__thunkpos;
  if (!yymatchChar(yy, '0'))  {
  goto l4;
  }
  yyDo(yy, yy_1_val, yy->__begin, yy->__end);
  goto l3;
  l4:;
  yy->__pos= yypos3; yy->__thunkpos= yythunkpos3;
  if (!yymatchChar(yy, '1'))  {
  goto l2;
  }
  yyDo(yy, yy_2_val, yy->__begin, yy->__end);
  }
  l3:;
  yyprintf((stderr, "  ok   %s @ %s\n", "val", yy->__buf+yy->__pos));
  return 1;
  l2:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "val", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_expr(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "expr"));
  {
  int yypos6= yy->__pos, yythunkpos6= yy->__thunkpos;
  if (!yy_val(yy))   {
  goto l7;
  }
  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_expr, yy->__begin, yy->__end);
  goto l6;
  l7:;
  yy->__pos= yypos6; yy->__thunkpos= yythunkpos6;
  if (!yy_subt(yy))   {
  goto l5;
  }
  yyDo(yy, yySet, -2, 0);  }
  l6:;
  l8:;
  {
  int yypos9= yy->__pos, yythunkpos9= yy->__thunkpos;
  {
  int yypos10= yy->__pos, yythunkpos10= yy->__thunkpos;
  if (!yymatchChar(yy, '+'))  {
  goto l11;
  }
  {
  int yypos12= yy->__pos, yythunkpos12= yy->__thunkpos;
  if (!yy_val(yy))   {
  goto l13;
  }
  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_expr, yy->__begin, yy->__end);
  goto l12;
  l13:;
  yy->__pos= yypos12; yy->__thunkpos= yythunkpos12;
  if (!yy_subt(yy))   {
  goto l11;
  }
  yyDo(yy, yySet, -1, 0);  }
  l12:;
  yyDo(yy, yy_3_expr, yy->__begin, yy->__end);
  goto l10;
  l11:;
  yy->__pos= yypos10; yy->__thunkpos= yythunkpos10;
  if (!yymatchChar(yy, '-'))  {
  goto l14;
  }
  {
  int yypos15= yy->__pos, yythunkpos15= yy->__thunkpos;
  if (!yy_val(yy))   {
  goto l16;
  }
  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_4_expr, yy->__begin, yy->__end);
  goto l15;
  l16:;
  yy->__pos= yypos15; yy->__thunkpos= yythunkpos15;
  if (!yy_subt(yy))   {
  goto l14;
  }
  yyDo(yy, yySet, -1, 0);  }
  l15:;
  yyDo(yy, yy_5_expr, yy->__begin, yy->__end);
  goto l10;
  l14:;
  yy->__pos= yypos10; yy->__thunkpos= yythunkpos10;
  if (!yymatchChar(yy, '*'))  {
  goto l17;
  }
  {
  int yypos18= yy->__pos, yythunkpos18= yy->__thunkpos;
  if (!yy_val(yy))   {
  goto l19;
  }
  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_6_expr, yy->__begin, yy->__end);
  goto l18;
  l19:;
  yy->__pos= yypos18; yy->__thunkpos= yythunkpos18;
  if (!yy_subt(yy))   {
  goto l17;
  }
  yyDo(yy, yySet, -1, 0);  }
  l18:;
  yyDo(yy, yy_7_expr, yy->__begin, yy->__end);
  goto l10;
  l17:;
  yy->__pos= yypos10; yy->__thunkpos= yythunkpos10;
  if (!yymatchChar(yy, '/'))  {
  goto l9;
  }
  {
  int yypos20= yy->__pos, yythunkpos20= yy->__thunkpos;
  if (!yy_val(yy))   {
  goto l21;
  }
  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_8_expr, yy->__begin, yy->__end);
  goto l20;
  l21:;
  yy->__pos= yypos20; yy->__thunkpos= yythunkpos20;
  if (!yy_subt(yy))   {
  goto l9;
  }
  yyDo(yy, yySet, -1, 0);  }
  l20:;
  yyDo(yy, yy_9_expr, yy->__begin, yy->__end);
  }
  l10:;
  goto l8;
  l9:;
  yy->__pos= yypos9; yy->__thunkpos= yythunkpos9;
  }
  yyDo(yy, yy_10_expr, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "expr", yy->__buf+yy->__pos));
  yyDo(yy, yyPop, 2, 0);
  return 1;
  l5:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "expr", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_true_or_false(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "true_or_false"));
  if (!yy_expr(yy))   {
  goto l22;
  }
  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_true_or_false, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "true_or_false", yy->__buf+yy->__pos));
  yyDo(yy, yyPop, 1, 0);
  return 1;
  l22:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "true_or_false", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_CLOSE(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "CLOSE"));
  if (!yymatchChar(yy, ')'))  {
  goto l23;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "CLOSE", yy->__buf+yy->__pos));
  return 1;
  l23:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "CLOSE", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_OPEN(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "OPEN"));
  if (!yymatchChar(yy, '('))  {
  goto l24;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "OPEN", yy->__buf+yy->__pos));
  return 1;
  l24:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "OPEN", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_NUMBER(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "NUMBER"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l25;
#undef yytext
#undef yyleng
  }
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l25;
  }
  l26:;
  {
  int yypos27= yy->__pos, yythunkpos27= yy->__thunkpos;
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l27;
  }
  goto l26;
  l27:;
  yy->__pos= yypos27; yy->__thunkpos= yythunkpos27;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l25;
#undef yytext
#undef yyleng
  }
  if (!yy__(yy))   {
  goto l25;
  }
  yyDo(yy, yy_1_NUMBER, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "NUMBER", yy->__buf+yy->__pos));
  return 1;
  l25:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "NUMBER", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_DIVIDE(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "DIVIDE"));
  if (!yymatchChar(yy, '/'))  {
  goto l28;
  }
  if (!yy__(yy))   {
  goto l28;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "DIVIDE", yy->__buf+yy->__pos));
  return 1;
  l28:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "DIVIDE", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_TIMES(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "TIMES"));
  if (!yymatchChar(yy, '*'))  {
  goto l29;
  }
  if (!yy__(yy))   {
  goto l29;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "TIMES", yy->__buf+yy->__pos));
  return 1;
  l29:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "TIMES", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_Value(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "Value"));
  {
  int yypos31= yy->__pos, yythunkpos31= yy->__thunkpos;
  if (!yy__(yy))   {
  goto l32;
  }
  if (!yy_NUMBER(yy))   {
  goto l32;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l32;
  }
  yyDo(yy, yy_1_Value, yy->__begin, yy->__end);
  goto l31;
  l32:;
  yy->__pos= yypos31; yy->__thunkpos= yythunkpos31;
  if (!yy__(yy))   {
  goto l33;
  }
  if (!yy_ID(yy))   {
  goto l33;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l33;
  }
  {
  int yypos34= yy->__pos, yythunkpos34= yy->__thunkpos;
  if (!yy_ASSIGN(yy))   {
  goto l34;
  }
  goto l33;
  l34:;
  yy->__pos= yypos34; yy->__thunkpos= yythunkpos34;
  }
  if (!yy__(yy))   {
  goto l33;
  }
  yyDo(yy, yy_2_Value, yy->__begin, yy->__end);
  goto l31;
  l33:;
  yy->__pos= yypos31; yy->__thunkpos= yythunkpos31;
  if (!yy__(yy))   {
  goto l30;
  }
  if (!yy_OPEN(yy))   {
  goto l30;
  }
  if (!yy__(yy))   {
  goto l30;
  }
  if (!yy_Expr(yy))   {
  goto l30;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l30;
  }
  if (!yy_CLOSE(yy))   {
  goto l30;
  }
  if (!yy__(yy))   {
  goto l30;
  }
  yyDo(yy, yy_3_Value, yy->__begin, yy->__end);
  }
  l31:;
  yyprintf((stderr, "  ok   %s @ %s\n", "Value", yy->__buf+yy->__pos));
  yyDo(yy, yyPop, 1, 0);
  return 1;
  l30:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "Value", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_MINUS(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MINUS"));
  if (!yymatchChar(yy, '-'))  {
  goto l35;
  }
  if (!yy__(yy))   {
  goto l35;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "MINUS", yy->__buf+yy->__pos));
  return 1;
  l35:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MINUS", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_PLUS(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PLUS"));
  if (!yymatchChar(yy, '+'))  {
  goto l36;
  }
  if (!yy__(yy))   {
  goto l36;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "PLUS", yy->__buf+yy->__pos));
  return 1;
  l36:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PLUS", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_Product(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "Product"));
  if (!yy__(yy))   {
  goto l37;
  }
  if (!yy_Value(yy))   {
  goto l37;
  }
  yyDo(yy, yySet, -2, 0);  if (!yy__(yy))   {
  goto l37;
  }
  l38:;
  {
  int yypos39= yy->__pos, yythunkpos39= yy->__thunkpos;
  {
  int yypos40= yy->__pos, yythunkpos40= yy->__thunkpos;
  if (!yy__(yy))   {
  goto l41;
  }
  if (!yy_TIMES(yy))   {
  goto l41;
  }
  if (!yy__(yy))   {
  goto l41;
  }
  if (!yy_Value(yy))   {
  goto l41;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l41;
  }
  yyDo(yy, yy_1_Product, yy->__begin, yy->__end);
  goto l40;
  l41:;
  yy->__pos= yypos40; yy->__thunkpos= yythunkpos40;
  if (!yy__(yy))   {
  goto l39;
  }
  if (!yy_DIVIDE(yy))   {
  goto l39;
  }
  if (!yy__(yy))   {
  goto l39;
  }
  if (!yy_Value(yy))   {
  goto l39;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l39;
  }
  yyDo(yy, yy_2_Product, yy->__begin, yy->__end);
  }
  l40:;
  goto l38;
  l39:;
  yy->__pos= yypos39; yy->__thunkpos= yythunkpos39;
  }
  yyDo(yy, yy_3_Product, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "Product", yy->__buf+yy->__pos));
  yyDo(yy, yyPop, 2, 0);
  return 1;
  l37:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "Product", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_Sum(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "Sum"));
  if (!yy__(yy))   {
  goto l42;
  }
  if (!yy_Product(yy))   {
  goto l42;
  }
  yyDo(yy, yySet, -2, 0);  if (!yy__(yy))   {
  goto l42;
  }
  l43:;
  {
  int yypos44= yy->__pos, yythunkpos44= yy->__thunkpos;
  {
  int yypos45= yy->__pos, yythunkpos45= yy->__thunkpos;
  if (!yy__(yy))   {
  goto l46;
  }
  if (!yy_PLUS(yy))   {
  goto l46;
  }
  if (!yy__(yy))   {
  goto l46;
  }
  if (!yy_Product(yy))   {
  goto l46;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l46;
  }
  yyDo(yy, yy_1_Sum, yy->__begin, yy->__end);
  goto l45;
  l46:;
  yy->__pos= yypos45; yy->__thunkpos= yythunkpos45;
  if (!yy__(yy))   {
  goto l44;
  }
  if (!yy_MINUS(yy))   {
  goto l44;
  }
  if (!yy__(yy))   {
  goto l44;
  }
  if (!yy_Product(yy))   {
  goto l44;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l44;
  }
  yyDo(yy, yy_2_Sum, yy->__begin, yy->__end);
  }
  l45:;
  goto l43;
  l44:;
  yy->__pos= yypos44; yy->__thunkpos= yythunkpos44;
  }
  yyDo(yy, yy_3_Sum, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "Sum", yy->__buf+yy->__pos));
  yyDo(yy, yyPop, 2, 0);
  return 1;
  l42:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "Sum", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_ASSIGN(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ASSIGN"));
  if (!yymatchChar(yy, '='))  {
  goto l47;
  }
  if (!yy__(yy))   {
  goto l47;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "ASSIGN", yy->__buf+yy->__pos));
  return 1;
  l47:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ASSIGN", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_ID(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ID"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l48;
#undef yytext
#undef yyleng
  }
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\000\000\000\000\000\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l48;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l48;
#undef yytext
#undef yyleng
  }
  if (!yy__(yy))   {
  goto l48;
  }
  yyDo(yy, yy_1_ID, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "ID", yy->__buf+yy->__pos));
  return 1;
  l48:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ID", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_Expr(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "Expr"));
  {
  int yypos50= yy->__pos, yythunkpos50= yy->__thunkpos;
  if (!yy_ID(yy))   {
  goto l51;
  }
  yyDo(yy, yySet, -2, 0);  if (!yy__(yy))   {
  goto l51;
  }
  if (!yy_ASSIGN(yy))   {
  goto l51;
  }
  if (!yy__(yy))   {
  goto l51;
  }
  if (!yy_Sum(yy))   {
  goto l51;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l51;
  }
  yyDo(yy, yy_1_Expr, yy->__begin, yy->__end);
  goto l50;
  l51:;
  yy->__pos= yypos50; yy->__thunkpos= yythunkpos50;
  if (!yy__(yy))   {
  goto l49;
  }
  if (!yy_Sum(yy))   {
  goto l49;
  }
  yyDo(yy, yySet, -1, 0);  if (!yy__(yy))   {
  goto l49;
  }
  yyDo(yy, yy_2_Expr, yy->__begin, yy->__end);
  }
  l50:;
  yyprintf((stderr, "  ok   %s @ %s\n", "Expr", yy->__buf+yy->__pos));
  yyDo(yy, yyPop, 2, 0);
  return 1;
  l49:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "Expr", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_Stmt(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "Stmt"));
  {
  int yypos53= yy->__pos, yythunkpos53= yy->__thunkpos;
  if (!yy__(yy))   {
  goto l54;
  }
  if (!yy_Expr(yy))   {
  goto l54;
  }
  yyDo(yy, yySet, -1, 0);  {
  int yypos55= yy->__pos, yythunkpos55= yy->__thunkpos;
  if (!yy_EOL(yy))   {
  goto l56;
  }
  goto l55;
  l56:;
  yy->__pos= yypos55; yy->__thunkpos= yythunkpos55;
  {
  int yypos57= yy->__pos, yythunkpos57= yy->__thunkpos;
  if (!yymatchDot(yy))   {
  goto l57;
  }
  goto l54;
  l57:;
  yy->__pos= yypos57; yy->__thunkpos= yythunkpos57;
  }
  }
  l55:;
  yyDo(yy, yy_1_Stmt, yy->__begin, yy->__end);
  goto l53;
  l54:;
  yy->__pos= yypos53; yy->__thunkpos= yythunkpos53;
  l58:;
  {
  int yypos59= yy->__pos, yythunkpos59= yy->__thunkpos;
  {
  int yypos60= yy->__pos, yythunkpos60= yy->__thunkpos;
  if (!yy_EOL(yy))   {
  goto l60;
  }
  goto l59;
  l60:;
  yy->__pos= yypos60; yy->__thunkpos= yythunkpos60;
  }
  if (!yymatchDot(yy))   {
  goto l59;
  }
  goto l58;
  l59:;
  yy->__pos= yypos59; yy->__thunkpos= yythunkpos59;
  }
  {
  int yypos61= yy->__pos, yythunkpos61= yy->__thunkpos;
  if (!yy_EOL(yy))   {
  goto l62;
  }
  goto l61;
  l62:;
  yy->__pos= yypos61; yy->__thunkpos= yythunkpos61;
  if (!yymatchDot(yy))   {
  goto l52;
  }
  }
  l61:;
  yyDo(yy, yy_2_Stmt, yy->__begin, yy->__end);
  }
  l53:;
  yyprintf((stderr, "  ok   %s @ %s\n", "Stmt", yy->__buf+yy->__pos));
  yyDo(yy, yyPop, 1, 0);
  return 1;
  l52:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "Stmt", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_MATH_SEPERATOR(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MATH_SEPERATOR"));
  {
  int yypos64= yy->__pos, yythunkpos64= yy->__thunkpos;
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l65;
#undef yytext
#undef yyleng
  }
  if (!yy_EOL(yy))   {
  goto l65;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l65;
#undef yytext
#undef yyleng
  }
  yyDo(yy, yy_1_MATH_SEPERATOR, yy->__begin, yy->__end);
  goto l64;
  l65:;
  yy->__pos= yypos64; yy->__thunkpos= yythunkpos64;
  if (!yy_EOF(yy))   {
  goto l63;
  }
  yyDo(yy, yy_2_MATH_SEPERATOR, yy->__begin, yy->__end);
  }
  l64:;
  yyprintf((stderr, "  ok   %s @ %s\n", "MATH_SEPERATOR", yy->__buf+yy->__pos));
  return 1;
  l63:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MATH_SEPERATOR", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_MATH_EQUALS(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MATH_EQUALS"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l66;
#undef yytext
#undef yyleng
  }
  if (!yymatchChar(yy, '='))  {
  goto l66;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l66;
#undef yytext
#undef yyleng
  }
  yyDo(yy, yy_1_MATH_EQUALS, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "MATH_EQUALS", yy->__buf+yy->__pos));
  return 1;
  l66:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MATH_EQUALS", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_MATH_OPEN(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MATH_OPEN"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l67;
#undef yytext
#undef yyleng
  }
  if (!yymatchChar(yy, '('))  {
  goto l67;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l67;
#undef yytext
#undef yyleng
  }
  yyDo(yy, yy_1_MATH_OPEN, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "MATH_OPEN", yy->__buf+yy->__pos));
  return 1;
  l67:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MATH_OPEN", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_MATH_CLOSE(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MATH_CLOSE"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l68;
#undef yytext
#undef yyleng
  }
  if (!yymatchChar(yy, ')'))  {
  goto l68;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l68;
#undef yytext
#undef yyleng
  }
  yyDo(yy, yy_1_MATH_CLOSE, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "MATH_CLOSE", yy->__buf+yy->__pos));
  return 1;
  l68:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MATH_CLOSE", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_MATH_op(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MATH_op"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l69;
#undef yytext
#undef yyleng
  }
  {
  int yypos70= yy->__pos, yythunkpos70= yy->__thunkpos;
  if (!yymatchChar(yy, '+'))  {
  goto l71;
  }
  goto l70;
  l71:;
  yy->__pos= yypos70; yy->__thunkpos= yythunkpos70;
  if (!yymatchChar(yy, '*'))  {
  goto l72;
  }
  goto l70;
  l72:;
  yy->__pos= yypos70; yy->__thunkpos= yythunkpos70;
  if (!yymatchChar(yy, '/'))  {
  goto l73;
  }
  goto l70;
  l73:;
  yy->__pos= yypos70; yy->__thunkpos= yythunkpos70;
  if (!yymatchChar(yy, '-'))  {
  goto l69;
  }
  }
  l70:;
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l69;
#undef yytext
#undef yyleng
  }
  yyDo(yy, yy_1_MATH_op, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "MATH_op", yy->__buf+yy->__pos));
  return 1;
  l69:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MATH_op", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_MATH_word(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MATH_word"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l74;
#undef yytext
#undef yyleng
  }
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\200\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l74;
  }
  l75:;
  {
  int yypos76= yy->__pos, yythunkpos76= yy->__thunkpos;
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\200\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l76;
  }
  goto l75;
  l76:;
  yy->__pos= yypos76; yy->__thunkpos= yythunkpos76;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l74;
#undef yytext
#undef yyleng
  }
  yyDo(yy, yy_1_MATH_word, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "MATH_word", yy->__buf+yy->__pos));
  return 1;
  l74:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MATH_word", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_exp(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "exp"));
  {
  int yypos78= yy->__pos, yythunkpos78= yy->__thunkpos;
  if (!yy__(yy))   {
  goto l79;
  }
  {
  int yypos82= yy->__pos, yythunkpos82= yy->__thunkpos;
  if (!yy_MATH_word(yy))   {
  goto l83;
  }
  goto l82;
  l83:;
  yy->__pos= yypos82; yy->__thunkpos= yythunkpos82;
  if (!yy_MATH_op(yy))   {
  goto l84;
  }
  goto l82;
  l84:;
  yy->__pos= yypos82; yy->__thunkpos= yythunkpos82;
  if (!yy_MATH_CLOSE(yy))   {
  goto l85;
  }
  goto l82;
  l85:;
  yy->__pos= yypos82; yy->__thunkpos= yythunkpos82;
  if (!yy_MATH_OPEN(yy))   {
  goto l86;
  }
  goto l82;
  l86:;
  yy->__pos= yypos82; yy->__thunkpos= yythunkpos82;
  if (!yy_MATH_EQUALS(yy))   {
  goto l79;
  }
  }
  l82:;
  l80:;
  {
  int yypos81= yy->__pos, yythunkpos81= yy->__thunkpos;
  if (!yy__(yy))   {
  goto l81;
  }
  {
  int yypos87= yy->__pos, yythunkpos87= yy->__thunkpos;
  if (!yy_MATH_word(yy))   {
  goto l88;
  }
  goto l87;
  l88:;
  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;
  if (!yy_MATH_op(yy))   {
  goto l89;
  }
  goto l87;
  l89:;
  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;
  if (!yy_MATH_CLOSE(yy))   {
  goto l90;
  }
  goto l87;
  l90:;
  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;
  if (!yy_MATH_OPEN(yy))   {
  goto l91;
  }
  goto l87;
  l91:;
  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;
  if (!yy_MATH_EQUALS(yy))   {
  goto l81;
  }
  }
  l87:;
  goto l80;
  l81:;
  yy->__pos= yypos81; yy->__thunkpos= yythunkpos81;
  }
  if (!yy_MATH_SEPERATOR(yy))   {
  goto l79;
  }
  yyDo(yy, yy_1_exp, yy->__begin, yy->__end);
  goto l78;
  l79:;
  yy->__pos= yypos78; yy->__thunkpos= yythunkpos78;
  if (!yy_something(yy))   {
  goto l77;
  }
  yyDo(yy, yy_2_exp, yy->__begin, yy->__end);
  }
  l78:;
  yyprintf((stderr, "  ok   %s @ %s\n", "exp", yy->__buf+yy->__pos));
  return 1;
  l77:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "exp", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_expression(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "expression"));
  if (!yy_exp(yy))   {
  goto l92;
  }
  l93:;
  {
  int yypos94= yy->__pos, yythunkpos94= yy->__thunkpos;
  if (!yy_exp(yy))   {
  goto l94;
  }
  goto l93;
  l94:;
  yy->__pos= yypos94; yy->__thunkpos= yythunkpos94;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "expression", yy->__buf+yy->__pos));
  return 1;
  l92:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "expression", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_s_qword(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "s_qword"));
  if (!yymatchChar(yy, 'q'))  {
  goto l95;
  }
  yyDo(yy, yy_1_s_qword, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "s_qword", yy->__buf+yy->__pos));
  return 1;
  l95:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "s_qword", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_s_dword(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "s_dword"));
  if (!yymatchChar(yy, 'd'))  {
  goto l96;
  }
  yyDo(yy, yy_1_s_dword, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "s_dword", yy->__buf+yy->__pos));
  return 1;
  l96:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "s_dword", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_s_word(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "s_word"));
  if (!yymatchChar(yy, 'w'))  {
  goto l97;
  }
  yyDo(yy, yy_1_s_word, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "s_word", yy->__buf+yy->__pos));
  return 1;
  l97:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "s_word", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_s_byte(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "s_byte"));
  if (!yymatchChar(yy, 'b'))  {
  goto l98;
  }
  yyDo(yy, yy_1_s_byte, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "s_byte", yy->__buf+yy->__pos));
  return 1;
  l98:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "s_byte", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_comma(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "comma"));
  if (!yymatchChar(yy, ','))  {
  goto l99;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "comma", yy->__buf+yy->__pos));
  return 1;
  l99:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "comma", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_reg(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "reg"));
  if (!yy_register_token(yy))   {
  goto l100;
  }
  if (!yy_word(yy))   {
  goto l100;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "reg", yy->__buf+yy->__pos));
  return 1;
  l100:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "reg", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_number(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "number"));
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l101;
  }
  l102:;
  {
  int yypos103= yy->__pos, yythunkpos103= yy->__thunkpos;
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l103;
  }
  goto l102;
  l103:;
  yy->__pos= yypos103; yy->__thunkpos= yythunkpos103;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "number", yy->__buf+yy->__pos));
  return 1;
  l101:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "number", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_REG__(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "REG__"));
  yyDo(yy, yy_1_REG__, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "REG__", yy->__buf+yy->__pos));
  return 1;
  l104:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "REG__", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_NUM__(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "NUM__"));
  yyDo(yy, yy_1_NUM__, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "NUM__", yy->__buf+yy->__pos));
  return 1;
  l105:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "NUM__", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_word(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "word"));
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\200\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l106;
  }
  l107:;
  {
  int yypos108= yy->__pos, yythunkpos108= yy->__thunkpos;
  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\200\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l108;
  }
  goto l107;
  l108:;
  yy->__pos= yypos108; yy->__thunkpos= yythunkpos108;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "word", yy->__buf+yy->__pos));
  return 1;
  l106:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "word", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_register_token(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "register_token"));
  if (!yymatchChar(yy, '%'))  {
  goto l109;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "register_token", yy->__buf+yy->__pos));
  return 1;
  l109:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "register_token", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_something(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "something"));
  l111:;
  {
  int yypos112= yy->__pos, yythunkpos112= yy->__thunkpos;
  {
  int yypos113= yy->__pos, yythunkpos113= yy->__thunkpos;
  if (!yy_EOL(yy))   {
  goto l113;
  }
  goto l112;
  l113:;
  yy->__pos= yypos113; yy->__thunkpos= yythunkpos113;
  }
  if (!yymatchDot(yy))   {
  goto l112;
  }
  goto l111;
  l112:;
  yy->__pos= yypos112; yy->__thunkpos= yythunkpos112;
  }
  {
  int yypos114= yy->__pos, yythunkpos114= yy->__thunkpos;
  if (!yy_EOL(yy))   {
  goto l115;
  }
  goto l114;
  l115:;
  yy->__pos= yypos114; yy->__thunkpos= yythunkpos114;
  if (!yymatchDot(yy))   {
  goto l110;
  }
  }
  l114:;
  yyprintf((stderr, "  ok   %s @ %s\n", "something", yy->__buf+yy->__pos));
  return 1;
  l110:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "something", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_EOF(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "EOF"));
  {
  int yypos117= yy->__pos, yythunkpos117= yy->__thunkpos;
  if (!yymatchDot(yy))   {
  goto l117;
  }
  goto l116;
  l117:;
  yy->__pos= yypos117; yy->__thunkpos= yythunkpos117;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "EOF", yy->__buf+yy->__pos));
  return 1;
  l116:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "EOF", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_EOL(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "EOL"));
  {
  int yypos119= yy->__pos, yythunkpos119= yy->__thunkpos;
  if (!yymatchChar(yy, '\n'))  {
  goto l120;
  }
  goto l119;
  l120:;
  yy->__pos= yypos119; yy->__thunkpos= yythunkpos119;
  if (!yymatchString(yy, "\r\n"))  {
  goto l121;
  }
  goto l119;
  l121:;
  yy->__pos= yypos119; yy->__thunkpos= yythunkpos119;
  if (!yymatchChar(yy, '\r'))  {
  goto l122;
  }
  goto l119;
  l122:;
  yy->__pos= yypos119; yy->__thunkpos= yythunkpos119;
  if (!yymatchChar(yy, ';'))  {
  goto l118;
  }
  }
  l119:;
  yyprintf((stderr, "  ok   %s @ %s\n", "EOL", yy->__buf+yy->__pos));
  return 1;
  l118:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "EOL", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_operands(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "operands"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l123;
#undef yytext
#undef yyleng
  }
  {
  int yypos124= yy->__pos, yythunkpos124= yy->__thunkpos;
  if (!yy_number(yy))   {
  goto l125;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l125;
#undef yytext
#undef yyleng
  }
  if (!yy_NUM__(yy))   {
  goto l125;
  }
  goto l124;
  l125:;
  yy->__pos= yypos124; yy->__thunkpos= yythunkpos124;
  if (!yy_reg(yy))   {
  goto l123;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l123;
#undef yytext
#undef yyleng
  }
  if (!yy_REG__(yy))   {
  goto l123;
  }
  }
  l124:;
  if (!yy__(yy))   {
  goto l123;
  }
  {
  int yypos126= yy->__pos, yythunkpos126= yy->__thunkpos;
  if (!yy_comma(yy))   {
  goto l126;
  }
  goto l127;
  l126:;
  yy->__pos= yypos126; yy->__thunkpos= yythunkpos126;
  }
  l127:;
  if (!yy__(yy))   {
  goto l123;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "operands", yy->__buf+yy->__pos));
  return 1;
  l123:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "operands", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy__(yycontext *yy)
{
  yyprintf((stderr, "%s\n", "_"));
  l129:;
  {
  int yypos130= yy->__pos, yythunkpos130= yy->__thunkpos;
  if (!yymatchClass(yy, (unsigned char *)"\000\002\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"))  {
  goto l130;
  }
  goto l129;
  l130:;
  yy->__pos= yypos130; yy->__thunkpos= yythunkpos130;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "_", yy->__buf+yy->__pos));
  return 1;
}

YY_RULE(int) yy_se(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "se"));
  {
  int yypos132= yy->__pos, yythunkpos132= yy->__thunkpos;
  if (!yymatchChar(yy, ')'))  {
  goto l133;
  }
  goto l132;
  l133:;
  yy->__pos= yypos132; yy->__thunkpos= yythunkpos132;
  if (!yymatchChar(yy, ']'))  {
  goto l134;
  }
  goto l132;
  l134:;
  yy->__pos= yypos132; yy->__thunkpos= yythunkpos132;
  if (!yymatchChar(yy, '}'))  {
  goto l131;
  }
  }
  l132:;
  yyprintf((stderr, "  ok   %s @ %s\n", "se", yy->__buf+yy->__pos));
  return 1;
  l131:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "se", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_size(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "size"));
  {
  int yypos136= yy->__pos, yythunkpos136= yy->__thunkpos;
  if (!yy_s_byte(yy))   {
  goto l137;
  }
  goto l136;
  l137:;
  yy->__pos= yypos136; yy->__thunkpos= yythunkpos136;
  if (!yy_s_word(yy))   {
  goto l138;
  }
  goto l136;
  l138:;
  yy->__pos= yypos136; yy->__thunkpos= yythunkpos136;
  if (!yy_s_dword(yy))   {
  goto l139;
  }
  goto l136;
  l139:;
  yy->__pos= yypos136; yy->__thunkpos= yythunkpos136;
  if (!yy_s_qword(yy))   {
  goto l135;
  }
  }
  l136:;
  yyprintf((stderr, "  ok   %s @ %s\n", "size", yy->__buf+yy->__pos));
  return 1;
  l135:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "size", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_ss(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ss"));
  {
  int yypos141= yy->__pos, yythunkpos141= yy->__thunkpos;
  if (!yymatchChar(yy, '('))  {
  goto l142;
  }
  goto l141;
  l142:;
  yy->__pos= yypos141; yy->__thunkpos= yythunkpos141;
  if (!yymatchChar(yy, '['))  {
  goto l143;
  }
  goto l141;
  l143:;
  yy->__pos= yypos141; yy->__thunkpos= yythunkpos141;
  if (!yymatchChar(yy, '{'))  {
  goto l140;
  }
  }
  l141:;
  yyprintf((stderr, "  ok   %s @ %s\n", "ss", yy->__buf+yy->__pos));
  return 1;
  l140:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ss", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_instruction(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "instruction"));
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l144;
#undef yytext
#undef yyleng
  }
  if (!yy_word(yy))   {
  goto l144;
  }
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l144;
#undef yytext
#undef yyleng
  }
  yyText(yy, yy->__begin, yy->__end);
#define yytext yy->__text
#define yyleng yy->__textlen

	parser_opcode_count = 0;
	parser_opcode_error = 0;
;
#undef yytext
#undef yyleng
  yyprintf((stderr, "  ok   %s @ %s\n", "instruction", yy->__buf+yy->__pos));
  return 1;
  l144:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "instruction", yy->__buf+yy->__pos));
  return 0;
}

YY_RULE(int) yy_asm(yycontext *yy)
{
  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "asm"));
  {
  int yypos146= yy->__pos, yythunkpos146= yy->__thunkpos;
  if (!yy_instruction(yy))   {
  goto l147;
  }
  {
  int yypos148= yy->__pos, yythunkpos148= yy->__thunkpos;
  if (!yy_ss(yy))   {
  goto l148;
  }
  if (!yy_size(yy))   {
  goto l148;
  }
  if (!yy_se(yy))   {
  goto l148;
  }
  goto l149;
  l148:;
  yy->__pos= yypos148; yy->__thunkpos= yythunkpos148;
  }
  l149:;
  if (!yy__(yy))   {
  goto l147;
  }
  if (!yy_operands(yy))   {
  goto l147;
  }
  l150:;
  {
  int yypos151= yy->__pos, yythunkpos151= yy->__thunkpos;
  if (!yy_operands(yy))   {
  goto l151;
  }
  goto l150;
  l151:;
  yy->__pos= yypos151; yy->__thunkpos= yythunkpos151;
  }
  {
  int yypos152= yy->__pos, yythunkpos152= yy->__thunkpos;
  if (!yy_EOL(yy))   {
  goto l153;
  }
  goto l152;
  l153:;
  yy->__pos= yypos152; yy->__thunkpos= yythunkpos152;
  if (!yy_EOF(yy))   {
  goto l147;
  }
  }
  l152:;
  goto l146;
  l147:;
  yy->__pos= yypos146; yy->__thunkpos= yythunkpos146;
  if (!yy_something(yy))   {
  goto l145;
  }
  yyDo(yy, yy_1_asm, yy->__begin, yy->__end);
  }
  l146:;
  yyprintf((stderr, "  ok   %s @ %s\n", "asm", yy->__buf+yy->__pos));
  return 1;
  l145:;
  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "asm", yy->__buf+yy->__pos));
  return 0;
}


#ifndef YY_PART

typedef int (*yyrule)(yycontext *yy);

YY_PARSE(int) YYPARSEFROM(YY_CTX_PARAM_ yyrule yystart)
{
  int yyok;
  if (!yyctx->__buflen)
    {
      yyctx->__buflen= YY_BUFFER_SIZE;
      yyctx->__buf= (char *)YY_MALLOC(yyctx, yyctx->__buflen);
      yyctx->__textlen= YY_BUFFER_SIZE;
      yyctx->__text= (char *)YY_MALLOC(yyctx, yyctx->__textlen);
      yyctx->__thunkslen= YY_STACK_SIZE;
      yyctx->__thunks= (yythunk *)YY_MALLOC(yyctx, sizeof(yythunk) * yyctx->__thunkslen);
      yyctx->__valslen= YY_STACK_SIZE;
      yyctx->__vals= (YYSTYPE *)YY_MALLOC(yyctx, sizeof(YYSTYPE) * yyctx->__valslen);
      yyctx->__begin= yyctx->__end= yyctx->__pos= yyctx->__limit= yyctx->__thunkpos= 0;
    }
  yyctx->__begin= yyctx->__end= yyctx->__pos;
  yyctx->__thunkpos= 0;
  yyctx->__val= yyctx->__vals;
  yyok= yystart(yyctx);
  if (yyok) yyDone(yyctx);
  yyCommit(yyctx);
  return yyok;
}

YY_PARSE(int) YYPARSE(YY_CTX_PARAM)
{
  return YYPARSEFROM(YY_CTX_ARG_ yy_asm);
}

YY_PARSE(yycontext *) YYRELEASE(yycontext *yyctx)
{
  if (yyctx->__buflen)
    {
      yyctx->__buflen= 0;
      YY_FREE(yyctx, yyctx->__buf);
      YY_FREE(yyctx, yyctx->__text);
      YY_FREE(yyctx, yyctx->__thunks);
      YY_FREE(yyctx, yyctx->__vals);
    }
  return yyctx;
}

#endif
void yyparse__(YY_CTX_PARAM_ char * in) {
	if (in == NULL) {
		yyfrom_FILE = true;
	}
	else {
		yyfrom_FILE = false;
		yy_FILE_string_pos = 0;
		yy_FILE_string = in;
	}
	while (yyparse(YY_CTX_ARG));
}
void yyparse__x(char * in, YY_CTX_PARAM_ yyrule yystart) {
	if (in == NULL) {
		yyfrom_FILE = true;
	}
	else {
		yyfrom_FILE = false;
		yy_FILE_string_pos = 0;
		yy_FILE_string = in;
	}
	while (YYPARSEFROM(YY_CTX_ARG_ yystart));
}
